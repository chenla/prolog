#   -*- mode: org; fill-column: 60 -*-
#+TITLE: Prolegomena References
#+AUTHOR: Brad Collins
#+EMAIL: brad@chenla.la
#+PROPERTY: header-args    :results drawer  :tangle ref-prolog.el

#+STARTUP: showall
#+PROPERTY: filename
#+TOC: headlines 4
  :PROPERTIES:
  :CUSTOM_ID: Prolegomena_References_()
  :Name:      /home/deerpig/proj/chenla/prolog/ref-prolog.org
  :Created:   2017-04-29T17:50@Prek Leap (11.642600N-104.919210W)
  :ID:        22d37595-e4ec-4b44-87c2-73e96ed916eb
  :VER:       546735262.598557129
  :BXID:      proj:GRO44-6794
  :END:

  :TREE:
  :BT: 


  :END:



* Scope Note                                       :SN:

The idea here is that every reference is a burr

For now we will include the bibtex entry for each reference
in a src block that is tangled to create latex references.
Later we will generate the bibtex from the metadata in the
Burr.

But these burrs will go beyond being only bibliographic
references, they can be definitions, authority records, and
blob records.

In fact, eventually, it should be relatively rare to have to
create these on your own.  There should be public catalogs
online that you can download locally or link to over the
Internet.

This is the thin edge of the web where BMF begins in ernest.

It doesn't matter where we begin -- here is as good a place
as any, but we will have to define everything in the
process, which will build out chenla/core  that will define 
all of the BMF burrs and eventually move most of the entries
here into larger collections.  The mechanism for this is yet
to be determined.  But hey, this is a bottom up process.
I've spent enough years thinking about it top down, so let's
see if we can no implement it bottom up.



* Notes towards the next Burs

This will be a literate program....  do we create a new repo
for it?  and should that be burs or saltmine?  say salt4e
since this will work locally as well as being a front end
for an external db it's close enough to what mu is doing
that I salt4e would be cool....

define a new org protocol  'bmf'

  :BXID:      proj:GRO44-6794

look up 'proj' in LINK and expand which gives us a local path to the
tspace index for the bxid.

The index is very simple:

  ("GR044-6794" "546735262.598557129" "22d37595-e4ec-4b44-87c2-73e96ed916eb")

Search list for GR044-6794 which will return all triples for GR044-6794.

Then sort by the car cdr and take the top one which will be most recent.

Finally grab the id for top one which, is then used to go to the burr
using the org id function.

So:

   bmf:/proj/GR044-6794

Goes to the latest version of the burr.  But you can also link to a
specific version by appending the version/time stamp.

   bmf:/proj/GR044-6794.546735262.598557129

--------

Then we will need:

  - function for indexing all of the bxids

  - version control -- which means you commit a burr which
    copies the old version into an archive and then gives
    a new id to the new version.  

    Do we want a commit string?  If we want to integrate the
    concept of literate version control -- where the comit
    string is a burr in its own right -- and can be a commit
    string, gloss, or scholia all of which are tied to
    specific versions, but glosses and scholia can be moved
    to new versions -- which will make the version process
    more complex, but this is the only way we can make this
    work -

    scholia can be inline, block or burr level -- so burr
    level scholia don't need to migrate, they are comments
    on the whole burr, but anything pointing to block or
    inline content must be tied to specific versions.




Once this basic lookup is done we can start working on the
external database 
